# 의존성 역전

## 영속성 어댑터

- `아웃고잉` 어댑터, 애플리케이션에 의해 호출됨
- 애플리케이션 서비스에서는 영속성 기능을 사용하기 위해 포트 인터페이스 호출
- 실제로 영속성 작업을 수행하고 DB 통신 책임을 가진 영속성 어댑터 클래스에 의해 구현

# 영속성 어댑터의 책임

1. 입력을 받음
    
    ⇒ 포트 인터페이스를 통해 입력 받고, 입력 모델은 도메인 엔티티나 연산 전용 객체
    
2. 입력을 데이터베이스 포맷으로 매핑
3. 입력을 데이터베이스로 보냄
4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑
5. 출력 반환

⇒ **영속성 어댑터 입력 모델이 애플리케이션 코어에 존재하여 어댑터가 변경되어도 코어에 영향** ❌

# 포트 인터페이스 나누기

> 필요 없는 화물을 운반하는 무언가에 의존하고 있으면
예상하지 못했던 문제가 생길 수 있다.
*- 로버트 C. 마틴*
> 

## 일반적인 방법

- 특정 엔티티가 필요로 하는 모든 DB 연산을 하나의 리포지토리 인터페이스에 넣어둠
- 의존하는 각 서비스는 인터페이스에서 단 하나의 메서드만 사용하더라도 **넓은 의존성**을 가짐

⇒ 맥락 내 필요하지 않은 메서드 내 생긴 의존성은 코드를 이해하고 테스트하기 어렵게 함

## 인터페이스 분리 원칙 준수

- 클라이언트가 오로지 자신이 필요로 하는 메서드만 알면 되도록 넓은 인터페이스를 특화된 인터페이스로 분리 필요
- 좁은 포트를 만드는 것은 코딩을 `플러그 앤 플레이` 경험으로 만듦

# 영속성 어댑터 나누기

모든 영속성 포트를 구현하는 한, 하나 이상의 클래스 생성을 금지하는 규칙은 없음

## 분리 방안

- 도메인 클래스 또는 애그리거트 하나당 하나의 영속성 어댑터 구현
    - 도메인 경계를 따라 자동으로 나눠짐
    - 추후 여러 개의 바운디드 컨텍스트의 영속성 요구사항을 분리하기에 유리

# 데이터베이스 트랜잭션

```java
package buckpal.application.service;

**@Transactional**
public class SendMoneyService implements SendMoneyUseCase {
      ...
}
```

- 트랜잭션은 하나의 특정 유스케이스에 대해 일어나는 모든 쓰기 작업에 걸쳐 있어야 함
- 영속성 어댑터는 어떤 DB 연산이 같은 유스케이스에 포함되는지 알지 못하기 때문에 트랜잭션 결정 불가
- **트랜잭션 설정 책임은 영속성 어댑터를 호출하는 서비스에 위임 필요**

# 결론

- 플러그인과 같은 영속성 어댑터를 만들어 풍부한 도메인 모델을 만들자
- 좁은 포트 인터페이스를 사용하여 포트마다 다른 방식으로 구현 가능한 유연성을 갖자
