# SRP: 단일 책임 원칙

> 컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.
> 

## 변경할 이유

- 변경할 이유가 한 가지라면 변경하더라도 컴포넌트는 기대한대로 동작할 것
- 컴포넌트 간 의존성을 통해 너무 쉽게 전파됨

## 위반할 경우

- 시간이 갈수록 변경하기 어려워짐
    - 유지보수 비용 증가
- 하나의 컴포넌트를 변경할 이유가 늘어남
    - 사이드 이펙트 발생 확률 증가

# DIP: 의존성 역전 원칙

> 코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.
> 

- 계층 간 의존성은 항상 다음 계층인 아래 방향을 가리킴
- SRP를 고수준에서 적용할 때 상위 계층들이 하위 계층에 비해 변경할 이유가 많아짐
- 의존성의 양쪽 코드를 모두 제어 가능할 때 의존성 역전 가능

## 적용 예시

- 엔티티를 도메인 계층으로 올리면 두 계층 간 순환 의존성이 발생
    - 이 부분에 DIP를 위와 같이 적용

# 클린 아키텍처

## 로버트 C. 마틴 💬

- 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함
- DIP의 도움으로 모든 의존성이 도메인 코드를 향하게 함

## 용어

- `코어` : 도메인 계층과 애플리케이션 계층을 합쳐 부르는 용어
- `유스케이스` : 단일 책임을 갖기 위해 세분화된 서비스

## 장점

- 도메인 코드에서는 특정 프레임워크에 특화된 코드를 가질 수 없음

# 헥사고날 아키텍처

포트와 어댑터 아키텍처로 불리기도 함

## 육각형 안

- 도메인 엔티티
- 유스케이스
    - 도메인 엔티티와 상호작용

⇒ 모든 의존성은 코어로 향함

## 육각형 바깥

- 어댑터
    - `왼쪽 어댑터` : 애플리케이션 코어 호출
    - `오른쪽 어댑터` : 애플리케이션 코어에 의해 호출
- 포트
    - 애플리케이션 코어와 어댑터들 간 통신을 가능하게 함
    - 포트가 코어에 있는 유스케이스에 의해 구현, 어댑터에 의해 호출되는 인터페이스가 됨

## 계층 구조

- 가장 바깥쪽 계층은 애플리케이션과 다른 시스템 간 번역을 담당하는 어댑터로 구성
- 포트와 유스케이스 구현체를 결합하여 애플리케이션 계층 구성
- 마지막 계층에는 도메인 엔티티가 위치

# 결론

- 의존성을 역전시켜 도메인 코드가 바깥쪽 코드에 의존하지 않게 함으로써 변경할 이유를 줄임
    - 변경할 이유가 적을수록 유지보수성 좋음
- 도메인 코드는 비즈니스에 맞게 모델링
- 영속성 코드와 UI 코드도 영속성 문제와 UI 문제에 맞게 자유롭게 모델링
