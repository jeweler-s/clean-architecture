# 테스트 피라미드

- 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고, 작은 크기의 테스트들에 대해 높은 커버리지 유지 필요
- 테스트가 비싸질수록 테스트의 커버리지 목표는 낮게 잡아야 함
- `단위 테스트`, `통합 테스트`, `시스템 테스트` 는 맥락에 따라 다름
    - `단위 테스트` : 하나의 클래스를 인스턴스화, 클래스의 인터페이스를 통해 기능 테스트
    - `통합 테스트` : 연결된 여러 유닛을 인스턴스화, 유닛들의 네트워크 검증
    - `시스템 테스트` : 애플리케이션을 구성하는 모든 객체 네트워크 검증

# `단위 테스트`로 도메인 엔티티 테스트하기

- 단위 테스트가 도메인 엔티티에 포함된 비즈니스 규칙 검증에 가장 적합
- 도메인 엔티티의 행동은 다른 클래스에 거의 의존하지 않으므로 다른 종류의 테스트 불필요

# `단위 테스트`로 유스케이스 테스트하기

- 유스케이스는 상태가 없기 때문에 특정 상태 검증 불가
- 서비스가 의존 대상의 특정 메서드와 상호작용 했는지 검증
- 테스트가 코드의 행동/구조 모두에 취약해짐 ⇒ 리팩토링 시 테스트 변경 가능성 증가
- **모든 동작이 아닌 핵심 동작만 검증**

# `통합 테스트`로 웹 어댑터 테스트하기

- 웹 어댑터는 HTTP를 통해 요청이 유스케이스를 통해 정상적으로 응답되는지 검증
- 웹 어댑터의 책임 대부분은 해당 테스트로 커버 가능

<aside>
💡

**단위 테스트가 아닌 통합 테스트인 이유?**
웹 컨트롤러가 네트워크의 일부로서 동작하는지 검증하고 `@WebMvcTest` 를 사용했기 때문

</aside>

# `통합 테스트`로 영속성 어댑터 테스트하기

- 데이터베이스 매핑 검증을 위해 통합 테스트 진행
- 데이터베이스를 모킹하지 않고 실제 데이터베이스 대상으로 진행 필요
    - 테스트 DB/프로덕션 DB 이원화 방지 등을 위해

# `시스템 테스트`로 주요 경로 테스트하기

- 전체 애플리케이션을 띄우고 API를 통해 요청을 보냄으로써 모든 계층이 동작하는지 검증
- 시스템 테스트는 단위 테스트와 통합 테스트가 발견하는 버그와는 다른 버그를 수정하게 함
    - ex) 계층 간 매핑 버그 등
- 여러 개의 유스케이스를 결합하여 시나리오 생성 시 유리

# 얼마만큼의 테스트가 충분할까?

- 라인 커버리지는 테스트 성공을 측정하는 데 있어 잘못된 지표
- 얼마나 마음 편하게 소프트웨어를 배포할 수 있느냐를 테스트의 성공 기준으로 삼으면 됨

## 헥사고날 아키텍처에서의 전략

- `도메인 엔티티` : 단위 테스트
- `유스케이스` : 단위 테스트
- `어댑터` : 통합 테스트
- `사용자가 취할 수 있는 중요 애플리케이션 경로` : 시스템 테스트

# 결론

- 헥사고날 아키텍처는 도메인 로직과 바깥으로 향한 어댑터 분리
- 입출력 포트는 테스트에서 뚜렷한 모킹 지점
    - 각 포트에 대해 모킹할지, 실제 구현을 이용할지 선택 가능
    - 포트 인터페이스가 좁을수록 유리
- **모킹하는 것이 너무 버겁거나 어떤 테스트를 해야할지 모르겠다면 이는 경고 🚨**
