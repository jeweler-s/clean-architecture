# 계층형 아키텍처

## 3계층 아키텍처

- `웹` : 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보냄
- `도메인` : 필요한 비즈니스 로직 수행
- `영속성` : 도메인 엔티티의 현재 상태를 조회하거나 변경하기 위해 컴포넌트 호출

## 장점

- 계층을 잘 이해하고 구성한다면 웹 계층이나 영속성 계층에 독립적으로 도메인 로직 작성 가능
- 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술 변경 가능
- 기존 기능에 영향을 주지 않고 새로운 기능 추가 가능
- 잘 만들어졌다면 선택의 폭을 넓히고 변화하는 요구사항과 외부 요인에 빠르게 대응 가능

## 단점

- 코드에 나쁜 습관들이 스며들기 쉬움
- 시간이 지날수록 소프트웨어를 점점 더 변경하기 어렵게 함
- 데이터베이스 주도 설계 유도

# 1️⃣ 데이터베이스 주도 설계 유도

## 비즈니스 관점

- 상태가 아닌 행동을 중심으로 모델링
- 행동이 상태를 바꾸는 주체

## 아키텍처 관점

- ORM 사용으로 인해 모든 것이 영속성 계층을 토대로 만들어짐
    - ORM 프레임워크를 계층형 아키텍처와 결합하면 비즈니스 규칙을 영속성 관점과 엮게 됨
- 영속성 계층과 도메인 계층 사이 강한 결합 발생
    - 계층형 아키텍처의 목표와 반대됨

# 2️⃣ 지름길을 택하기 쉬워진다

## 계층형 아키텍처의 규칙

- 특정한 계층에서는 같은 계층에 있는 컴포넌트나 아래에 있는 계층만 접근 가능

## 상위 계층 접근

- 컴포넌트를 계층 아래로 내려 접근 가능하게 바꿈 (❌)

## 비대해진 영속성 계층

- 컴포넌트를 아래 계층으로 내릴수록 비대해짐
- 헬퍼/유틸리티 컴포넌트를 아래 계층으로 내릴 가능성이 커짐

# 3️⃣ 테스트하기 어려워진다

## 일반적인 변화의 형태

- 계층형 아키텍처 사용 시 계층을 건너뛰는 경우가 많음
    - ex) 웹 계층에서 영속성 계층에 접근
    

## 문제점

- 도메인 로직을 웹 계층에 구현하게 됨
- 웹 계층 테스트에서 도메인 계층 + 영속성 계층 Mocking 필요
    - 테스트 설정이 복잡해져 테스트를 작성하지 않을 확률이 커짐
    - 웹 컴포넌트의 규모가 커지며 영속성 컴포넌트에 의존성이 많이 쌓이며 테스트의 복잡도 증가

# 4️⃣ 유스케이스를 숨긴다

> 기능을 추가하거나 변경할 적절한 위치를 빠르게 찾기 위해 아키텍처는 탐색에 도움이 되어야 함
> 

- 도메인 로직이 여러 계층에 흩어지기 쉬워 새로운 기능 추가 시 추가할 위치 찾기 어려움
- 도메인 서비스의 너비에 대한 규칙을 강제하지 않아 아주 넓은 서비스가 만들어질 가능성 존재
    - 방대해지고 의존도가 높아져 테스트하고 유지보수하기 어려워짐

# 5️⃣ 동시 작업이 어려워짐

- 계층별로 담당자를 나누어 개발할 수 없음
    - 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 계층을 먼저 개발해야 함
- 데이터베이스 주도 설계를 하지 않는 경우 인터페이스만 먼저 제공 가능
- 넓은 서비스 존재 시 서로 다른 기능을 동시에 작업하기 더 어려움

# 결론

- 계층형 아키텍처는 잘못 사용되기 쉬움
    - 함정을 염두하여 사용하자
